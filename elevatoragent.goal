init module {
	knowledge{
			
		% onRoute succeeds when Level is in the current direction Dir relative to the floor the agent is at.
		% Note that onRoute only succeeds when the elevator car is "docked", i.e. atFloor(Here) succeeds for
		% some floor (see also the belief section).
		onRoute(Level, Dir) :- atFloor(Here), dir(Dir), Diff is Level-Here, (Diff<0 -> Dir=down; Dir=up).
		
		% Check if the level of the elevator is the same as Level of the requested task
		distanceScore(Level, DistanceScore) :- dir(Dir), Dir == up, carPosition(L), A is ceiling(L), A == Level, DistanceScore is 1.
		distanceScore(Level, DistanceScore) :- dir(Dir), Dir == down, carPosition(L), A is floor(L), A == Level, DistanceScore is 1.
		
		% Look if the level is in the direction the elevator is currently going
		onPath(Level,A) :- carPosition(L), Level < round(L), dir(Dir), Dir == up, A = 0.  
		onPath(Level,A) :- carPosition(L), Level < round(L), dir(Dir), Dir == down, A = 1.  
		onPath(Level,A) :- carPosition(L), Level > round(L), dir(Dir), Dir == up, A = 1.  
		onPath(Level,A) :- carPosition(L), Level > round(L), dir(Dir), Dir == down, A = 0.  
		
		% Check if the tasks level is in the direction the elevator is going if so then calculate the distance to this floor if not on it's current path return 0
		distanceScore(Level, DistanceScore) :- onPath(Level,A), A == 1, carPosition(L), floorCount(K),  Distance is abs(Level - L), DistanceScore is (1-(Distance / K)).
		distanceScore(Level, DistanceScore) :- onPath(Level,A), A == 0, DistanceScore is 0.
		
		% Update score based on whether there is space left or not.
		score(Level, Dir, Score) :- spaceLeft(H), H > 0, score(Level, Dir, Score, 1, 1).
		score(Level, Dir, Score) :- spaceLeft(H), H == 0, Score is -100.
		
		% Update score based on whether the elevator is onroute in the corresponding direction
		score(Level, Dir, Score, CurScore, I) :- I == 1, onRoute(Level,Dir) , NewScore is CurScore + 1, score(Level, Dir, Score, NewScore, 2).
		score(Level, Dir, Score, CurScore, I) :- I == 1, not(onRoute(Level,Dir)), NewScore is CurScore - 1, score(Level, Dir, Score, NewScore, 2).
		
		% Update score based on the distance and current direction of the elevator
		score(Level, Dir, Score, CurScore, I) :- I == 2, distanceScore(Level,DistanceScore), NewScore is CurScore + DistanceScore, Score is NewScore.
	}
	beliefs{
		% The direction that will be shown to the people at the next stop.
		% This remains the intended direction of movement until there are no more
		% planned stops in that direction.
		dir(down).
		% Initially, it is unknown whether doors are open or closed.
		doorState(unknown).
		% Initially, there are zero people in the elevator
		people(0).
		% The starting Position of the cars (is irrelevant since it get's updated immediatly)
		carPosition(0).
		% Keeps track how long an elevator isn't doing anything
		idle(0).
	}
	goals{
		atFloor(1), dir(up).
	}
	actionspec{
		% The action goto(Level, Dir) moves the elevator car to floor Level. It can
		% only be performed if the elevator car is docked and not moving, i.e.,
		% atFloor(Here) holds for some Here.
		% When the elevator arrives at the requested floor, the Dir light will turn on.
		goto(Level, Dir) {
		   pre{ atFloor(Here), dir(DirNow), doorState(closed) }
		   post{ not(dir(DirNow)), dir(Dir) }
		}
	}
}
	
main module {
	program {
		% Goto the nearest floor that the agent wants to go to.
		if a-goal( atFloor(Level), dir(Dir) ),
			bel( atFloor(Here), Distance is abs(Level-Here) ),
		    not(a-goal( atFloor(OtherLevel),
				OtherDistance is abs(OtherLevel-Here), OtherDistance<Distance) )
		then goto(Level, Dir).
	}
}
	
event module {
	program {
		% Set initial percepts into belief base
		%%%%
		
		% Set the initial capacity of the elevator and send the information to the manager.
		if bel( percept(capacity(N)) ) then insert( capacity(N) ) + insert( spaceLeft(0) ).
		
		% Updates the current Position of the Car
		forall bel( percept(carPosition(L)), not(carPosition(L)), carPosition(K) ) do delete( carPosition(K) ) + insert( carPosition(L) ).

		% Update the amount of people currently in the elevator
		forall bel( percept(people(N)), people(X), capacity(Y), Z is Y-N, spaceLeft(H) ) do delete(people(X) ) + insert(people(N)) + delete(spaceLeft(H))  + insert(spaceLeft(Z)).
		
		% The atFloor(Level) percept is received only when elevator has stopped at a floor Level.
		forall bel( percept(atFloor(Level)), not(atFloor(Level)) ) do insert( atFloor(Level) ).
		forall bel( atFloor(Level), not(percept(atFloor(Level))) ) do delete( atFloor(Level) ).
				
		% Send messages to the manager to inform about the amount of floor and which Floor Buttons are on
		%%%%
				
		% Set the total floor count environment and send the information to the manager.
		if bel( percept(floorCount(N)) ) then insert( floorCount(N) ) + (manager).send(floorCount(N)).
		
		% The fButton(Level,Dir) percept indicates that the up or down (Dir) button on floor Level has been pressed.
		forall bel( percept(fButtonOn(Level,Dir)), not(fButtonOn(Level,Dir)), score(Level,Dir,Score) ) do insert( fButtonOn(Level,Dir) ) + (manager).send(fButtonOn(Level,Dir)).
		forall bel( fButtonOn(Level,Dir), not(percept(fButtonOn(Level,Dir))) ) do delete( fButtonOn(Level,Dir) ) + (manager).send(not(fButtonOn(Level,Dir))).
		
		% Check States of the elevator
		%%%%
		
		% Check if the Elevator is Idle
		if bel(atFloor(X), idle(Y), Z is Y + 1) then insert(idle(Z)) + delete(idle(Y)).
		if bel(not(atFloor(X)), idle(Y), Y > 0) then insert(idle(0)) + delete(idle(Y)).
		% Go to a Floor where the button has been pressed if no floors are assigned and elevator is still Idle
		if bel(idle(Y), fButtonOn(Level,Dir), Y >= 200 ) then adopt( atFloor(Level), dir(Dir) ) + insert(idle(0)) + delete(idle(Y)). 
		
		% Checks the current state of the door and updates it accordingly
		forall bel( percept(doorState(New)), doorState(Old) ) do insert( not(doorState(Old)), doorState(New) ).
	
		% Receive and send messages from/to the Manager
		%%%%
		
		% Calculate score if agent receives messages from the manager and if it has not sent the score yet for the Floor and Direction.
		forall bel(received(Sender,calculateScore(Level, Dir)), score(Level,Dir,Score) , not(sent(manager,score(Level, Dir,Score)))) do (manager).send(score(Level,Dir,Score)).
		
		% Receive message that the elevators score was the highest and insert the task and adopts the Floor and Direction into his goals
		if bel(received(manager,task(Level,Dir))) then insert(task(Level,Dir)) + adopt( atFloor(Level), dir(Dir) ).
		
		% If a task has been completed inform the manager that it has been completed 
		forall bel(task(Y,Dir)), not(goal(atFloor(Y),dir(Dir))) do (manager).send(taskCompleted(Y,Dir)).
		% If a task is completed by someone else stop doing this goal unless it's a goal from an eButton
		forall bel(received(manager,completed(Level,Dir)), not(eButtonOn(Level, Dir))), goal(atFloor(Level), dir(Dir)) do drop(atFloor(Level), dir(Dir)).
				
		% The eButton(Level) percept is received when the elevator button on floor Level has been pressed
		forall bel( percept(eButtonOn(Level)), dir(Dir) ) do insert( eButtonOn(Level, Dir) ) + adopt( atFloor(Level), dir(Dir) ).
		forall bel( eButtonOn(Level,Dir), not(percept(eButtonOn(Level))) ) do delete( eButtonOn(Level,Dir) ).
			
		% Clean up the received and sent messages in the mailbox
		forall bel(received(Agent, Message)) do delete(received(Agent, Message)).
		forall bel(sent(Agent, Message)) do delete(sent(Agent, Message)).
	}
}
